
- 后端返回的数据结构  
```
let arr = [
    {id: 1, name: '部门1', pid: 0},
    {id: 2, name: '部门2', pid: 1},
    {id: 3, name: '部门3', pid: 1},
    {id: 4, name: '部门4', pid: 3},
    {id: 5, name: '部门5', pid: 4},
]

```
function dataToTree(dataList, id, list) {
  for (let item of dataList) {
    if (item.pid === id) {
      list.push(item);
    }
  }
  for (let i of list) {
    i.children = [];
    dataToTree(dataList, i.id, i.children);
  }
  return list
}


- 需要转成的数据结构  
``` 
[
    {
        "id": 1,
        "name": "部门1",
        "pid": 0,
        "children": [
            {
                "id": 2,
                "name": "部门2",
                "pid": 1,
                "children": []
            },
            {
                "id": 3,
                "name": "部门3",
                "pid": 1,
                "children": [
                    // 结果 ,,,
                ]
            }
        ]
    }
]
```

- 方法一，递归 时间复杂度o(n^2)
```
function arrayToTree(arr, rootNode) {
    const tree = []
    arr.forEach(item => {
      if (item.pid === rootNode) {
      // 找到根节点之后, 就去找下面有没有对应的子节点
      const children = arrayToTree(arr, item.id)
        // 如果 children 的长度大于0, 说明找到了子节点
        // children.length > 0 ? (item.children = children) : (item.children = [])
        item.children = children
        tree.push(item) // 将内容加入数组中
      }
    })
    return tree
}
```

- 方法二，map 实现的时间复杂度为O(2n)，需要一个Map把数据存储起来，空间复杂度O(n)
```
function arrayToTree(items) {
  const result = [];   // 存放结果集
  const itemMap = {};  // 
    
  // 先转成map存储
  for (const item of items) {
    itemMap[item.id] = {...item, children: []}
  }
  
  for (const item of items) {
    const id = item.id;
    const pid = item.pid;
    const treeItem =  itemMap[id];
    if (pid === 0) {
      result.push(treeItem);
    } else {
      if (!itemMap[pid]) {
        itemMap[pid] = {
          children: [],
        }
      }
      itemMap[pid].children.push(treeItem)
    }

  }
  return result;
}
```

- 方法三，最佳方案,先把数据转成Map去存储，之后遍历的同时借助对象的引用，直接从Map找对应的数据做存储。不同点在遍历的时候即做Map存储,有找对应关系。时间复杂度为O(n)，需要一个Map把数据存储起来，空间复杂度O(n)
```
function arrayToTree(items) {
  const result = [];   // 存放结果集
  const itemMap = {};  // 
  for (const item of items) {
    const id = item.id;
    const pid = item.pid;

    if (!itemMap[id]) {
      itemMap[id] = {
        children: [],
      }
    }

    itemMap[id] = {
      ...item,
      children: itemMap[id]['children']
    }

    const treeItem =  itemMap[id];

    if (pid === 0) {
      result.push(treeItem);
    } else {
      if (!itemMap[pid]) {
        itemMap[pid] = {
          children: [],
        }
      }
      itemMap[pid].children.push(treeItem)
    }

  }
  return result;
}

```
### 给定不同面额的硬币 coins 和一个总金额 amount,编写一个函数来计算可以凑成总金额所需的最少的硬币个数

```
function coinChange(coins, amount) {
  let dp = new Array(amount+1).fill(Infinity);

  for(let i=0;i<amount;i++){
    for(let coin of coins){
      if(i>=coin){
        dp[i] = Math.min(dp[i], dp[i-coin]+1)
      }
    }
  }

  return dp[amount-1]=== Infinity? -1: dp[amount-1]
}
```

```
coinChange([1, 2, 5], 11); //3
coinChange([2, 4], -1) // -1
coinChange([1, 2, 4, 5, 10], 100) //10
```

```
解析：https://juejin.cn/post/6962001868104925192
动态规划算法是计算机科学算法中最重要也是最常用的一个算法， 巧妙的利用它可以解决很多复杂的问题，另外也频繁的出现在各大互联网公司的面试中，因此掌握它是十分必要的。
但该算法对于初学者来说，要想彻底的掌握理解它并非易事，本系列教程将带领大家一起来学习该算法，通过经典的案列介绍和解题分析，试图归纳出一套统一的方法来解决动态规划类题目。本系列重点介绍分析问题的思路和方法，而非直接告诉你答案，给您不一样的分析问题的思路。
首先我们来看一道非常经典的“凑硬币”题目：
面值为1元、3元、5元的硬币若干，如何用最少的硬币凑够11元？
解题思路：
步骤1：用函数的形式来表示题目结果。
设f(x) = y，该函数表示凑够x元，最少的硬币数量为y。 举例如下：

凑够1元最少的硬币数量为1，则可表示为f(1) = 1
凑够11元最少的硬币数量为3，则可表示为f(11) = 3

步骤2：分析递推情况。
凑够11元，我们需要多次选择，如： 第一次选择1元，则还需要凑够11 - 1 = 10元；
第二次选择3元，则还需要凑够10 - 3 = 7元； 。。。
如果我们选择了一枚1元硬币，则f(11) = 1 + f(11-1)，表示凑够11元选择了一枚1元硬币，那么还剩下需要凑够11-1 = 10元的硬币数量f(10)。
同理如果选择3元则f(11) = 1 + f(11-3)，如果选择5元则f(11) = 1 + f(11-5)。
根据题目要求凑够11元使用最少的硬币，所以
f(11) = min{ 1+f(10) , 1+f(8), 1+f(6)}
注：此处大家要充分理解f(x)函数的含义，f(x)表示凑够x元最少需要的硬币数量。
通过分析f(11) 我们知道要想求解f(11) 必须先求解f(10), f(8), f(6)。
f(10) = min{1+f(10-1), 1+f(10-3), 1+f(10-5)}
f(8) = min{1+f(8-1), 1+f(8-3), 1+f(8-5)}
f(6) = min{1+f(6-1), 1+f(6-3), 1+f(6-5)} 。。。
故，要想求解f(11)，必须先求解f(10),f(8),f(6)，而要求解f(10)必须先求解f(9), f(7), f(5)，其他的同理，所以当我们计算了前面函数的值后，自然就能非常方便的得到后面的函数结果。这就是动态规划算法的魅力所在。
在认真分析f(11)之后，我们很容易的得出一般情况即：
f(i) = min{ 1+f(i-1), 1+f(i-3), 1+f(i-5)}
凑够i元，可以有三种方案，分别是选择一枚1元、一枚3元或一枚5元，然后选择这三种方案中最小的值。这就是我们得出的针对一般情况的递推结果。这个递推公式对于求解动态规划题目来说显得尤为重要。
以上就是我们分析递推的情况，不知您理解了与否。
步骤3：算法实现
在我们了解问题的解决思路后，我们可以选择任何一门熟悉的编程语言去实现，如c, java等。
如果你不了解算法思想，不了解分析问题的思路和方法，即使你精通任何一门编程语言也无济于事，因为你无从下手，这就是一直强调的算法思想、分析问题思路和方法的重要性。
当你了解问题的解决思路后，并不表示你一定就能够编程实现它。关于本题的编程实现，我们将开辟新的文章来介绍，分析在编程实现时候需要注意的一些问题。如您感兴趣欢迎关注文章结尾的公众号。
总结：
针对任何一个动态规划的题目，我们基本都可以按照上面的三个步骤来分析，后面的文章将继续详细讲解分析思路。
```
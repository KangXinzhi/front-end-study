## 贪心 
每一步都选择当前最优解，跟之前的选择无关

1. 找零钱
    1. 100， 50， 20，10， 5， 1
    2. 每一次都可以按照这个当前能找大的最大值 最总能够得出全部最优解



## 动态规划
求极值
每一步的状态，都依赖于之前的状态




vue中的虚拟DOM， diff 最长递增子序列


### leetcode 509 斐波那契数列

斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1

```javascript
var fib = function(n) {
    let dp=[];
    dp[0]=0;
    dp[1]=1;
    for(let i=2;i<=n;i++){
        dp[i]=dp[i-1]+dp[i-2];
    }

    return dp[n];
};
```


### leetcode 322. 零钱兑换
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

```javascript
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    if(amount === 0 ){
        return 0;
    }
    let dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0;

    for(let i=1; i<=amount;i++){
        for(let coin of coins){
            if(i - coin >= 0){
                dp[i] = Math.min(dp[i-coin] + 1, dp[i])
            }
        }
    }

    return dp[amount] === Infinity ? -1 : dp[amount]
};
```

### leetcode300. 最长递增子序列

动态规划思路：
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
   let dp = new Array(nums.length).fill(1);
   
   for(let i = 0; i<nums.length;i++){
        for(let j = i-1; j>=0; j--){
            if(nums[i]>nums[j]){
                dp[i]=Math.max(dp[i], dp[j]+1);
            }
        }
   }

   return Math.max(...dp)
};
```

贪心思路+二分查找
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  let arr = [nums[0]];

  for(let i=0; i<nums.length; i++){
    if(nums[i]>arr[arr.length-1]){
        arr.push(nums[i])
    }else{
        // 找到arr中第一个比nums[i]大的数据，修改它
        let left = 0;
        let right = arr.length;

        while(left<right){
            let mid = (left + right)>>1;
            if(arr[mid]<nums[i]){
                left = mid+1;
            }else{
                right = mid;
            }
        }
        arr[left] = nums[i]
    }
  }
    return arr.length;

};
// nums = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];
// 0	[0]
// 8	[0, 8]
// 4	替换 8 → [0, 4]
// 12	[0, 4, 12]
// 2	替换 4 → [0, 2, 12]
// 10	替换 12 → [0, 2, 10]
// 6	替换 10 → [0, 2, 6]
// 14	[0, 2, 6, 14]
// 1	替换 2 → [0, 1, 6, 14]
// 9	替换 14 → [0, 1, 6, 9]
// 5	替换 6 → [0, 1, 5, 9]
// 13	[0, 1, 5, 9, 13]
// 3	替换 5 → [0, 1, 3, 9, 13]
// 11	替换 13 → [0, 1, 3, 9, 11]
// 7	替换 9 → [0, 1, 3, 7, 11]
// 15	[0, 1, 3, 7, 11, 15]
```
在在Vue中，处理最长递增子序列（LIS）时选择贪心+二分算法而非动态规划（DP），主要基于以下原因：

1. 时间复杂度优势
贪心+二分的时间复杂度为 O(n log n)，而DP的时间复杂度是 O(n²)。对于前端应用，尤其是处理大量动态节点时，O(n log n)的性能显著优于O(n²)，能更高效地完成DOM diff计算，确保流畅的用户体验。

2. 准确性问题澄清
贪心+二分算法能够正确计算LIS的长度。虽然它维护的序列元素可能并非真实的LIS元素（例如，通过替换末尾值为更小的数来允许更长的潜在序列），但最终生成的序列长度是正确的。

在Vue的场景中，关键在于LIS的长度而非具体序列。Vue利用LIS确定哪些子节点位置稳定（无需移动），其余节点只需插入或移动。只要长度正确，移动次数就能最小化（次数为 n - length_of_LIS），具体序列内容不影响优化结果。

3. 实现细节确保有效性
Vue在实现中通过记录**前驱索引（parent数组）**和回溯生成最终的稳定序列。虽然贪心过程中可能替换元素，但通过维护额外信息，算法仍能正确构建一个有效的LIS（可能不唯一，但长度正确且满足需求）。

例如，对于新子节点索引数组 [3, 2, 1, 4]，贪心算法可能生成 [2, 4] 或 [3, 4]，但长度均为2，均只需移动两次节点，优化效果相同。

4. 场景适用性
DOM diff的目标是最小化操作次数，而非追求理论上的“完美序列”。贪心算法在高效性和结果充分性之间达到平衡，完全满足Vue的实际需求。

总结
Vue采用贪心+二分法，因其在时间效率上远胜DP，且能正确得到LIS长度及有效序列，从而确保DOM操作的最优性能。用户对“准确性”的疑虑源于误解算法目标——Vue仅需足够长的稳定序列以减少移动，而非唯一的“正确”序列。
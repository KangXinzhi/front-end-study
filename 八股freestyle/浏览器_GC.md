GC：浏览器的垃圾回收机制（内存释放机制）
1、栈内存释放
1)加载页面，形成一个全局的上下文，只有页面关闭后，全局上下文才会被释放。
2)函数执行会形成一个私有的上下文，进栈执行；当函数中代码执行完成，大部分情况下，形成的上下文都会被出栈释放掉，以此优化栈内存大小；
2、堆内存释放
方案一：（例如谷歌）：查找引用  
浏览器在空闲或者指定时间内，查看所有的堆内存，把没有被任何东西占用的堆内存释放掉；但是占用着的是不被释放的；  
方案二：（例如IE）：引用计数  
创建了堆内存，被占用一次，则浏览器计数+1,取消占用则计数 -1。当记录的数字为零的时候，则内存释放掉；某些情况会导致记数混乱出现“内存泄漏”的现象。  

v8垃圾回收
首先js因为是单线程，垃圾回收会占用主线程，导致页面卡顿，所以需要一个算法或者说策略，而v8采用的是分代式回收，而垃圾回收在堆中分成了很多部分用作不同的作用（我在说什么啊！当时），回收主要表现在新老生代上，新生代就活得短一点的对象，老生代就活得长一点的对象。
“在新生代里有一个算法，将新生代分成了两个区，一个FORM,一个TO，每次经过Scavenge会将FORM区中的没引用的销毁，然后活着的TO区调换位置，反复如此，当经过一次acavange后就会晋升的老生代还有个条件就是TO区的内存超过多少了也会晋升。”
“而老生代，采用标记清除和标记整理，但标记清除会造成内存不连续，所以会有标记整理取解决掉内存碎片，就是清理掉边界碎片”
“为什么TO超过25%要晋升老生代？”
“为了不影响后续FORM空间的分配“
“标记清除是怎么清除的？”
”垃圾回收会构建一个根列表，从根节点去访问那些变量，可访问到位活动，不可就是垃圾”

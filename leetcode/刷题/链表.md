### leetcode 206. 反转链表

```js
var reverseList = function(head) {
    let cur = head;
    let pre = null;

    while(cur){
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }

    return pre;
};
```

### leetcode 19. 删除链表的倒数第N个节点

```js
var removeNthFromEnd = function(head, n) {
    let pre = { next: head }; // 哨兵节点，防止删除头节点时出错

    let length = 0;
    let current = head;

    // 计算链表长度
    while (current) {
        length++;
        current = current.next;
    }

    head = pre;
    let count = 0; // 从 0 开始索引

    // 找到要删除节点的前一个节点
    while (count < length - n) {
        count++;
        head = head.next;
    }

    // 删除目标节点
    head.next = head.next.next;

    return pre.next; // 返回新的头节点
};
```

### leetcode 21 合并两个有序链表

题目描述
输入： 两个升序链表 list1 和 list2。
输出： 一个新的升序链表，其节点由 list1 和 list2 的所有节点组成。

示例 1：

复制
编辑
输入：list1 = [1,2,4], list2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：

复制
编辑
输入：list1 = [], list2 = []
输出：[]
示例 3：

复制
编辑
输入：list1 = [], list2 = [0]
输出：[0]

```
var mergeTwoLists = function(list1, list2) {
    let dummy = {
        next: null,
    };

    let list3 = dummy;
    while(list1 || list2){
        if(!list1){
            list3.next = list2;
            list2 = list2.next;
        }else if(!list2){
            list3.next = list1;
            list1 = list1.next;
        }else if(list1.val>list2.val){
            list3.next = list2;
            list2 = list2.next;
        }else{
            list3.next = list1;
            list1 = list1.next;
        }
        list3 = list3.next;
    }

    return dummy.next;
};
```

## leetcode 876. 链表的中间结点
```
var middleNode = function(head) {
    let dummy = {
        next: head
    }

    let count = 0;
    while(head){
        count += 1;
        head = head.next;
    }

    count = count>>1;

    while(count>0){
        dummy = dummy.next;
        count--;
    }

    return dummy.next
};
```



### leetcode 234. 回文链表
```
var isPalindrome = function(head) {
    // 边界情况处理
    if (!head || !head.next) return true;

    // 使用快慢指针找到链表的中点
    let slow = head;
    let fast = head;
    while (fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // 此时slow指向链表的中点（或中点的前一个节点，如果链表节点总数是偶数）
    // 复制链表的后半部分，并反转
    let prev = null;
    let curr = slow.next; // 从中点的下一个节点开始复制和反转
    slow.next = null; // 断开链表，使得前半部分和后半部分分离

    while (curr) {
        let next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }

    // prev现在指向反转后链表的后半部分头部
    let p1 = head; // 原始链表的前半部分头部
    let p2 = prev; // 反转后链表的后半部分头部

    // 检查前半部分和反转后的后半部分是否相同
    while (p2) {
        if (p1.val !== p2.val) {
            return false; // 如果出现不匹配的节点值，则不是回文
        }
        p1 = p1.next;
        p2 = p2.next;
    }

    return true; // 所有节点值均匹配，是回文
};
```

leetcode 160. 相交链表
```
var getIntersectionNode = function(headA, headB) {
    if (!headA || !headB) return null;

    let pA = headA, pB = headB;
    
    while (pA !== pB) {
        pA = pA === null ? pA.next : headB;
        pB = pB === null ? pB.next : headA;
    }

    return pA; // 或者 return pB，因为最后它们相等
};

```

总结
不会死循环的原因：

指针不会无限循环回到起点，因为它们会交换链表，确保每个节点都只访问两次。

总步数固定为 a + b，必然会到达交点或 null。

有交点时，指针相遇终止，无交点时，指针都变 null 终止。


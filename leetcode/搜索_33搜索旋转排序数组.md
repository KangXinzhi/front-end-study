题目描述：

给定一个经过旋转的有序数组，你需要找到其中最小的元素。

示例 1:

输入: [3,4,5,1,2]

输出: 1

示例 2:

输入: [4,5,6,7,0,1,2]

输出: 0

解题思路：

由于数组是有序的并且经过旋转，因此可以考虑使用二分查找的思想来解决。可以先将数组的中间元素与右侧元素进行比较，判断中间元素在哪个递增区间中，从而确定下一步查找的方向。

思路

可以发现，无论数组旋转了多少次，它都可以被分为两段，每一段都是有序的。因此，可以通过比较中间元素和目标元素，来判断目标元素在哪一段中，并且在有序的一段中继续查找，如下所示：

- 1.如果中间元素 nums[mid] === target，则返回 mid。

- 2.如果 nums[left] <= nums[mid]，说明左半部分是有序的。

  a. 如果 target 在有序的左半部分中，则将右指针 right 赋值为 mid - 1，继续在左半部分中查找。

  b. 如果 target 不在有序的左半部分中，则将左指针 left 赋值为 mid + 1，继续在右半部分中查找。

- 3.如果 nums[mid] < nums[right]，说明右半部分是有序的。

  a. 如果 target 在有序的右半部分中，则将左指针 left 赋值为 mid + 1，继续在右半部分中查找。

  b. 如果 target 不在有序的右半部分中，则将右指针 right 赋值为 mid - 1，继续在左半部分中查找。

代码实现：


// 递归
```
var search = function (nums, target) {
  return binarySearch(nums, target, 0, nums.length - 1)

  function binarySearch(nums, target, left, right) {
    if (left > right) {
      return -1;
    }
    const mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return mid;
    }

    if (nums[left] <= nums[mid]) { // 左半部分有序
      if (nums[left] <= target && target < nums[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    } else { // 右半部分有序
      if (nums[mid] < target && target <= nums[right]) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return binarySearch(nums,target,left,right)
  }
};
```

// 迭代
```
var search = function(nums, target) {
    let left = 0, right = nums.length - 1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (nums[mid] === target) {
            return mid;
        }
        if (nums[left] <= nums[mid]) { // 左半部分有序
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else { // 右半部分有序
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
};

```
题目描述：

给定一个二叉树，找到该树中两个指定节点的最近公共祖先。

一个节点也可以是它自己的祖先。

解题思路：

这道题可以使用递归来解决。首先，如果根节点为空或者根节点等于其中一个给定的节点，则返回根节点。否则，递归地在左子树和右子树中查找这两个节点。如果左子树和右子树中都找到了这两个节点，那么根节点就是它们的最近公共祖先。如果只在左子树中找到了这两个节点，那么它们的最近公共祖先也在左子树中，否则它们的最近公共祖先就在右子树中。

具体实现：

如果根节点为空或者根节点等于其中一个给定的节点，则返回根节点。
在左子树中查找给定的节点，如果都找到了，那么递归查找左子树，否则递归查找右子树。
在右子树中查找给定的节点，如果都找到了，那么递归查找右子树，否则递归查找左子树。
如果左子树和右子树都找到了这两个节点，那么根节点就是它们的最近公共祖先，否则返回左子树或右子树中找到的节点。
代码实现：

```
var lowestCommonAncestor = function(root, p, q) {
    if (!root || root === p || root === q) {
        return root;
    }
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    if (left && right) {
        return root;
    } else if (left) {
        return left;
    } else {
        return right;
    }
};
```

时间复杂度：O(n)，其中 n 是二叉树中的节点个数。在最坏情况下，要遍历整棵二叉树才能找到最近公共祖先。

空间复杂度：O(h)，其中 h 是二叉树的高度。递归调用的栈空间大小取决于二叉树的高度。在最坏情况下，二叉树呈现链式结构，树的高度为 n，此时栈空间的大小为 O(n)。
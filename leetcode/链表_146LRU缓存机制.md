```
题目描述：

设计一个 LRU（最近最少使用）缓存机制。该缓存应该支持以下操作：获取数据和写入数据。

获取数据时，如果缓存中存在对应的数据，则直接返回该数据。否则，返回 -1。

写入数据时，如果缓存未满，则直接将新数据插入到缓存中。如果缓存已满，则需要先删除最久未使用的数据，再将新数据插入缓存中。

LRU 缓存应该支持如下操作：

get(key) - 如果key存在于缓存中，则返回key对应的value值；否则，返回 -1。
put(key, value) - 如果key不存在于缓存中，则将(key, value)插入缓存中；如果缓存已满，则删除最近最少使用的元素，再将(key, value)插入缓存中。
在两种操作都需要O(1)的时间复杂度内完成。

示例：

LRUCache cache = new LRUCache(2); // 缓存容量为 2

cache.put(1, 1);
cache.put(2, 2);
cache.get(1); // 返回 1
cache.put(3, 3); // 该操作会使得关键字 2 作废
cache.get(2); // 返回 -1 (未找到)
cache.put(4, 4); // 该操作会使得关键字 1 作废
cache.get(1); // 返回 -1 (未找到)
cache.get(3); // 返回 3
cache.get(4); // 返回 4
```

解法：

LRU Cache 通常可以用哈希表和双向链表来实现。哈希表可以快速找到指定的数据，双向链表则可以快速插入、删除数据，并且可以维护数据的访问时间，最近访问的数据排在链表头，最久未访问的数据排在链表尾。

使用哈希表和双向链表实现 LRU Cache 的具体思路如下：
- 使用哈希表 Map 存储缓存的键值对，哈希表中的每个键值对对应双向链表中的一个节点。
- 双向链表中的节点按照访问时间从新到旧排列，头节点是最近访问的数据，尾节点是最久未访问的数据。
- 每次访问缓存中的数据时，将访问的数据节点移动到链表头部。
- 每次插入数据时，先在哈希表中查找是否已经存在该数据。如果存在，则将该数据节点移动到链表头部；否则，新建一个数据节点，并将其插入到链表头部，然后在哈希表中创建对应的键值对。
- 当缓存已满时，将链表尾部的数据节点删除，并在哈希表中删除对应的键值对。

```
class ListNode {
  constructor(key, val) {
    this.val = val;
    this.key = key;
    this.next = null;
    this.prev = null;
  }
}

class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.size = 0;
    this.cache = new Map();
    this.head = new ListNode(null, null);
    this.tail = new ListNode(null, null);
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }

  get(key) {
    if (!this.cache.has(key)) {
      return -1;
    }

    const node = this.cache.get(key);
    this.moveToHead(node);
    return node.val;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      const node = this.cache.get(key);
      node.val = value;
      this.moveToHead(node);
    } else {
      const newNode = new ListNode(key, value);
      this.cache.set(key, newNode);

```
var reverseList = function(head) {
  if(!head||!head.next){
    return head;
  }
  const newReverseList = reverseList(head.next);
  head.next.next = head
  head.next = null;
  return newReverseList;
};
```


```
// 递归：
var reverse = function(pre, head) {
    if(!head) return pre;
    const temp = head.next;
    head.next = pre;
    pre = head
    return reverse(pre, temp);
}

var reverseList = function(head) {
    return reverse(null, head);
};
```

```
// 递归2
var reverse = function(head) {
    if(!head || !head.next) return head;
    // 从后往前翻
    const pre = reverse(head.next);
    head.next = pre.next;
    pre.next = head;
    return head;
}

var reverseList = function(head) {
    let cur = head;
    while(cur && cur.next) {
        cur = cur.next;
    }
    reverse(head);
    return cur;
};
```